## GOROOT

Go 语言安装根目录的路径，也就是 GO 语言的安装路径

## GOPATH

若干工作区目录的路径。 最新版本 go mod 会逐渐取代 

## GOBIN

GO 程序生成的可执行文件（executable file）的路径	

## GO MOD





## 数组

数组类型的值的长度是固定的，数组的长度在声明它的时候就必须给定，并且之后不会再改变

数组的长度是其类型的一部分

数组的容量永远等于其长度，都是不可变的

## 切片

切片的类型字面量中只有元素的类型，而没有长度

切片的长度可以自动地随着其中元素数量的增长而增长，但不会随着元素数量的减少而减小

切片容量的是可以确定的，cap函数，但是扩容时候的扩容倍数是不确定的

切片只有扩容才会对底层数组的引用发生改变

## 字典

键和元素的最大不同在于，键的类型是受限的，而元素却可以是任意类型的

Go 语言字典的键类型不可以是函数类型、字典类型和切片类型

## 通道

并发安全

当容量为0时，我们可以称通道为非缓冲通道，也就是不带缓冲的通道

而当容量大于0时，我们可以称为缓冲通道，也就是带有缓冲的通道

非缓冲通道是在用同步的方式传递数据

缓冲通道则在用异步的方式传递数据

接收操作有延迟性，关闭通道由发送通道完成

select语句只能与通道联用

## 函数

函数是一等的公民

函数类型属于引用类型

所有传给函数的参数值都会被复制，函数在其内部使用的并不是参数值的原值，而是它的副本

## 方法

方法隶属的类型其实并不局限于结构体类型，但必须是某个自定义的数据类型，并且不能是任何接口类型

对于任何数据类型，只要它的方法集合中完全包含了一个接口的全部特征（即全部的方法），那么它就一定是这个接口的实现类型

## 其他

##### Go 不同类型直接不能相互赋值，不存在隐式类型转换，必须显式强转

##### Go 语言的数组类型则属于值类型，同属值类型的有基础数据类型以及结构体类型。Go 语言的切片类型属于引用类型，同属引用类型的还有字典类型、通道类型、函数类型等

##### 切片看做是对数组的一层简单的封装，因为在每个切片的底层数据结构中，一定会包含一个数组。数组可以被叫做切片的底层数组，而切片也可以被看作是对数组的某个连续片段的引用

##### 卫述语句是指被用来检查关键的先决条件的合法性，并在检查未通过的情况下立即终止当前代码块执行的语句。在 Go 语言中，if 语句常被作为卫述语句

##### Go 语言中，我们可以通过为一个类型编写名为String的方法，来自定义该类型的字符串表示形式，fmt.Printf函数会自己去寻找它

##### struct{}类型值的表示法只有一个，即：struct{}{}。并且，它占用的内存空间是0字节

##### Go 语言中，只有类型相同的值之间才有可能被允许进行判等操作

##### 卫述语句：被用来检查后续操作的前置条件并进行相应处理的语句

##### Go 语言中，因 panic 导致程序结束运行的退出状态码一般都会是2

##### defer语句就是被用来延迟执行代码的。延迟到该语句所在的函数即将执行结束的那一刻，无论结束执行的原因是什么

##### 在同一个函数中，defer函数调用的执行顺序与它们分别所属的defer语句的出现顺序（更严谨地说，是执行顺序）完全相反

## 面试题

##### Go 语言在多个工作区中查找依赖包的时候是以怎样的顺序进行的？

设置的环境变量GOPATH的值决定顺序

##### 如果在多个工作区中都存在导入路径相同的代码包会产生冲突吗？

不会产生冲突。因为代码包的查找是按照已给定的顺序逐一地在多个工作区中进行的

##### 总执行顺序的角度

引入的包 -> 当前包的变量常量 -> init()[多个同一包则按照顺序执行] -> main函数

##### 依赖包执行顺序

被依赖的总是优先执行初始化，一个包只会被初始化一次。
a引入b，b引入c，则执行顺序c -> b -> a

##### 单个包执行顺序的角度

总的前提:按照包中源文件名的字典顺序来排序执行
当前包排序后的变量常量 -> 排序后的init()

##### Go 语言中的类型推断

类型推断是一种编程语言在编译期自动解释表达式类型的能力

Go 语言只能用于对变量或常量的初始化

##### 如果一个变量与其外层代码块中的变量重名会出现什么状况？

* 首先，代码引用变量的时候总会最优先查找当前代码块中的那个变量
* 其次，如果当前代码块中没有声明以此为名的变量，那么程序会沿着代码块的嵌套关系，从直接包含当前代码块的那个代码块开始，一层一层地查找
* 一般情况下，程序会一直查到当前代码包代表的代码块。如果仍然找不到，那么 Go 语言的编译器就会报错了

##### 不同代码块中的重名变量与变量重声明中的变量区别到底在哪儿？

变量重声明，在统一代码块。 可重名变量在不同代码块

##### 怎样估算切片容量的增长？

* 一旦一个切片无法容纳更多的元素，Go 语言就会想办法扩容。但它并不会改变原来的切片，而是会生成一个容量更大的切片，然后将把原有的元素和新元素一并拷贝到新切片中。新切片的容量将会是原切片容量的 2 倍
* .当原切片的长度大于或等于1024时，Go 语言将会以原容量的1.25倍作为新容量的基准。新容量基准会被调整（不断地与1.25相乘），直到结果不小于原长度与要追加的元素数量之和

##### 切片的底层数组什么时候会被替换？

一个切片的底层数组永远不会被替换。生成了新的切片，而没有对原切片，及其底层数组做任何改动

##### 对通道的发送和接收操作都有哪些基本的特性？

* 对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的
* 发送操作和接收操作中对元素值的处理都是不可分割的
* 发送操作在完全完成之前会被阻塞。接收操作也是如此

通道中的同一个元素值来说，发送操作和接收操作之间也是互斥的

##### 发送操作和接收操作在什么时候会引发 panic？

* 一个已初始化，但并未关闭的通道来说，收发操作一定不会引发 panic，但是通道一旦关闭，再对它进行发送操作，就会引发 panic
* 试图关闭一个已经关闭了的通道，也会引发 panic。注意，接收操作是可以感知到通道的关闭的，并能够安全退出

##### 单向通道有什么应用价值？

单向通道最主要的用途就是约束其他代码的行为

##### 闭包

表面上看，我们只是延迟实现了一部分程序逻辑或功能而已，但实际上，我们是在动态地生成那部分程序逻辑